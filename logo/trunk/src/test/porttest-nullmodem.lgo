;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file contains functional tests for the following primitives
; 
; PORTREADARRAY
; PORTREADCHAR
; PORTWRITEARRAY
; PORTWRITECHAR
;
; It assumes there is a null modem connecting COM4 to COM5.
; Since many modern computers don't have null modems, it's sufficient to
; use a software emulator, such as com0com.
;
; Because FMSLogo is limited to having only one COM port open at a time,
; all test cases must invoke a second FMSLogo instance to operate on the
; other side of the null modem.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LOAD "testlib.lgo

TO NULLMODEMTEST.WRITEARRAY.8BIT

  ; Because FMSLogo is limited to having only one COM port open at
  ; a time, this test must invoke a second FMSLogo instance to
  ; operate on the other port.

  ; Open the port before starting the FMSLogo instance that writes to it.
  ; Otherwise there will be a deadlock (the writer will block waiting
  ; for someone to open the other side of the reader port, and this
  ; this program will block on the other instance).
  PORTOPEN :readport
  PORTMODE "9600,n,8,1

  ; TODO: collect the output of PORTWRITEARRAY and test it.
  RUNLOGOPROGRAM (WORD
    "|TO RUNTEST\n|
    "|  ; Populate a buffer with all legal values from 0 - 255\n|
    "|  MAKE "buffer ARRAY 256\n|
    "|  REPEAT 256 [ SETITEM REPCOUNT :buffer (REPCOUNT - 1) ]\n|
    "|\n|
    "|  ; Use PORTWRITEARRAY to write all of the data\n|
    "|  PORTOPEN "| :writeport "|\n|
    "|  PORTMODE "9600,n,8,1\n|
    "|  SHOW PORTWRITEARRAY 256 :buffer\n|
    "|  PORTCLOSE\n|
    "|\n|
    "|END\n|
    "|\n|
    "|MAKE "startup [RUNTEST BYE]\n|
  )

  ; We should be able to read all 256 bytes.
  ; Values from 0-127 appear as written.
  ; Values from 128-255 are negative.
  REPEAT 128 [
    SIMPLEREPORTTEST [PORTREADCHAR] REPCOUNT-1
  ]
  REPEAT 128 [
    SIMPLEREPORTTEST [PORTREADCHAR] REPCOUNT - 1 - 128
  ]

  ; The 257th PORTREADCHAR should output -1, to indicate
  ; that no more data are available.
  SIMPLEREPORTTEST [PORTREADCHAR] -1

  ; Close the reader port
  PORTCLOSE

END

TO NULLMODEMTEST.WRITEARRAY.7BIT

  ; Open the port before starting the FMSLogo instance that writes to it.
  ; Otherwise there will be a deadlock (the writer will block waiting
  ; for someone to open the other side of the reader port, and this
  ; this program will block on the other instance).
  PORTOPEN :readport
  PORTMODE "9600,n,7,1

  ; TODO: collect the output of PORTWRITEARRAY and test it.
  RUNLOGOPROGRAM (WORD
    "|TO RUNTEST\n|
    "|  ; Populate a buffer with all legal values from 0 - 255\n|
    "|  MAKE "buffer ARRAY 256\n|
    "|  REPEAT 256 [ SETITEM REPCOUNT :buffer (REPCOUNT - 1) ]\n|
    "|\n|
    "|  ; Use PORTWRITEARRAY to write all of the data\n|
    "|  PORTOPEN "| :writeport "|\n|
    "|  PORTMODE "9600,n,8,1\n|
    "|  SHOW PORTWRITEARRAY 256 :buffer\n|
    "|  PORTCLOSE\n|
    "|\n|
    "|END\n|
    "|\n|
    "|MAKE "startup [RUNTEST BYE]\n|
  )

  ; We should be able to read all 256 bytes.
  ; Values from 0-127 appear as written.
  ; Values from 128-255 are masked to 7-bits, per the port mode.
  REPEAT 128 [
    SIMPLEREPORTTEST [PORTREADCHAR] REPCOUNT-1
  ]
  REPEAT 128 [
    SIMPLEREPORTTEST [PORTREADCHAR] REPCOUNT-1
  ]

  ; The 257th PORTREADCHAR should output -1, to indicate
  ; that no more data are available.
  SIMPLEREPORTTEST [PORTREADCHAR] -1

  ; Close the reader port
  PORTCLOSE

END

TO NULLMODEMTEST
  LOCAL [readport writeport]
  MAKE "readport  "COM4
  MAKE "writeport "COM5

  NULLMODEMTEST.WRITEARRAY.8BIT
  NULLMODEMTEST.WRITEARRAY.7BIT
END
