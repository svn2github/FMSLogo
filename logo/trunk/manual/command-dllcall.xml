<section id="command-dllcall">
<title>DLLCALL</title>
<indexterm><primary>DLLCALL</primary></indexterm>

<variablelist>

<varlistentry><term>Synopsis</term>
<listitem>
<synopsis><command>DLLCALL</command> <parameter>function_parameter_list</parameter>
(<command>DLLCALL</command> <parameter>function_parameter_list</parameter> <parameter>dllname</parameter>)</synopsis>
</listitem>
</varlistentry>

<varlistentry><term>Description</term>
<listitem>
<para>
Calls a native Windows function with the given arguments and outputs the function's return value.
The function must be exported by a DLL which was loaded with <link linkend="command-dllload">DLLLOAD</link>.
</para>

<para>
The <parameter>function_parameter_list</parameter> is of the form <userinput>[typef function type1 arg1 type2 arg2 type3 arg3 ...]</userinput>.
</para>

<para>
<parameter>function</parameter> must be a word that exactly matches symbol that is exported from the DLL.
For Win32 functions that take a parameter of type TCHAR, the exported symbol probably ends in either W or A, even if you wouldn't call it like that from C.
</para>

<para>
The "type" parameters are interpreted according to the table:

<informaltable frame='all'>
  <tgroup cols='2'>
    <thead>
      <row><entry>Given Type</entry> <entry>Interpreted As Type</entry></row>
    </thead>
    <tbody>
      <row><entry><userinput>V</userinput></entry><entry>void</entry></row>
      <row><entry><userinput>W</userinput></entry><entry>WORD</entry></row>
      <row><entry><userinput>L</userinput></entry><entry>DWORD</entry></row>
      <row><entry><userinput>F</userinput></entry><entry>DOUBLE</entry></row>
      <row><entry><userinput>S</userinput></entry><entry>LPSTR</entry></row>
    </tbody>
  </tgroup>
</informaltable>
</para>


<para>
DLLCALL interprets (and outputs) the function's return value as being of the type specified by <parameter>typef</parameter>, then parses it into a list, as with <link linkend="command-parse">PARSE</link>.
It passes <parameter>arg1</parameter> as a <parameter>type1</parameter>, <parameter>arg2</parameter> as a <parameter>type2</parameter>, and so on.
Keep in mind that the win32 "stdcall" convention pass arguments from right to left, so arg1 is really the last parameter.
</para>

<para>
If the optional <parameter>dllname</parameter> input is given, then DLLCALL will only look for the function within that DLL.
</para>

<para>
DLLCALL is meant for experienced programmers who are familiar with the native Windows calling conventions.
If you do not properly match the argument list the results will be unpredictable and likely crash &PRODUCTNAME;.
DLLCALL can handle a wide variety of function calls but certainly not all.
</para>

<para>
DLLCALL allows to extend the reach of &PRODUCTNAME; when its existing commands are insufficient.
You can write your own DLL with a compatible call interface to call more complex interfaces.
</para>

</listitem>
</varlistentry>

<varlistentry><term>Example</term>
<listitem>
<para>
<programlisting><userinput>; Equivalent to the C call
;   MessageBox(NULL, "Do you like &PRODUCTNAME;?", "Question", MB_YESNO);

DLLLOAD "user32.dll
IGNORE DLLCALL [L MessageBoxA L 4 S [Question] S [Do you like &PRODUCTNAME;?] L 0]</userinput>

<replaceable>See a message box pop up.</replaceable>

<userinput>DLLFREE</userinput>
</programlisting>
</para>

</listitem>
</varlistentry>

</variablelist>

</section>
