to addBonus :type
  if :type = 1 [

    if or :quit :reset [ stop ]
    make "timeLeft :timeLeft - 1
    make "score :score + 5
    updateStatusBonus
    updateStatusScore
    waitStop 1
    if :timeLeft > 0 [ addBonus :type ]
  ]
  if :type = 2 [
    if or :quit :reset [ stop ]
    make "lives :lives - 1
    make "score :score + 400
    updateStatusScore
    updateStatusLives
    waitStop 40
    if :lives > 1 [ addBonus :type ]
  ]
end

to buttonDraw :num :draw
  ; Draws or erases the button at index :num

  local [ bdTurtle bdPos bdHeading bdPen ]
  make "bdTurtle turtle
  setturtle 0

  ; backup the turtle's location so that it can be restored
  make "bdPos pos
  make "bdHeading heading
  make "bdPen pen
  setpc[ 255 255 0 ] ; yellow
  penup setpos item 3 ( item :num :buttonList )
  drawText item 1 ( item :num :buttonList ) "getLength
  seth 270
  penup fd :textLength/2 tfd 9 rt 90

  ; Draw the button's border
  sbitblock round( :textLength + 13 * :textScale + 2) round( 38 * :textScale + 1 )

  if :draw [
    pendown
    repeat 2 [
      tfd 8 fd 22 * :textScale tfd 8 rt 90
      tfd 8 fd :textLength tfd 5 rt 90
    ]
    penup tfd 9 rt 90 tfd 9
    make "tempPos pos
    drawText item 1 (item :num :buttonList ) "draw

    setpos :tempPos
    make "x round( first :tempPos )
    make "y round( last :tempPos )
    setxy :x :y
    seth 180 tfd 4 lt 90
    pendown
    ifelse( ( item 1 (item :num :buttonList) ) = [Instructions] ) [ tfd 6 fd 1 ] [ tfd 11 fd 1 ]  ;underline the first letter
  ]

  ; restore the turtle
  setturtle 0
  penup setpos :bdPos
  seth :bdHeading
  setpen :bdPen
  setturtle :bdTurtle
end

to buttonHit
  local [ bhTurtle bhPos bhHeading bhPen bhDone bhNum]
  make "bhTurtle turtle
  setturtle 0
  make "bhPos pos
  make "bhHeading heading
  make "bhPen pen
  make "bhNum 0
  make "bhDone "false
  do.while [
    make "bhNum :bhNum + 1
    if item 2 (item :bhNum :buttonList) [
      drawText item 1 ( item :bhNum :buttonList ) "getLength
      make "x1 (first item 3 ( item :bhNum :buttonList )) - :textLength/2 - 10*:textScale
      make "x2 (first item 3 ( item :bhNum :buttonList )) + :textLength/2 + 6*:textScale
      make "y1 last item 3 ( item :bhNum :buttonList )
      make "y2 (last item 3 ( item :bhNum :buttonList )) + 42 * :textScale
      if( and ((first mousepos) > :x1) ((first mousepos) < :x2) ((last mousepos) > :y1) ((last mousepos) < :y2) ) [

        ;Menu
        if :bhNum = 1 [
          menuOn "true
          make "bhDone "true
        ]

        ;Menu Off
        if :bhNum = 2 [
          menuOn "false
        ]

        ;Play
        if :bhNum = 3 [ commandPlay ]

        ;Instructions
        if :bhNum = 4 [ commandInstructions ]

        ;Quit
        if :bhNum = 5 [
          make "quit "true
          make "open.quit "true
        ] 

        ;High Scores
        if :bhNum = 6 [ commandHighScores ]

        ;High Scores Done
        if :bhNum = 7 [ commandDone ]

        ;Instructions Done
        if :bhNum = 8 [ commandDone ]

        ;Continue
        if :bhNum = 9 [
          make "paused "false
        ]
  
        ;Reset
        if :bhNum = 10 [
          make "paused "false
          make "reset "true
        ]
      ]
    ]
  ][ and :bhNum < :numButtons not :bhDone ]
  setturtle 0
  penup setpos :bhPos
  seth :bhHeading
  setpen :bhPen
  setturtle :bhTurtle
end

to buttonOn :num :draw
  setitem :num :buttonList ( list (item 1 ( item :num :buttonList )) :draw (item 3 ( item :num :buttonList )) )
  buttonDraw :num :draw 
end

to capturekeyboardinput
  ( keyboardon [ processKey keyboardvalue "true  ]
               [ processKey keyboardvalue "false ] )
end

to checkScreen
  make "x item 3 machine
  make "y item 4 machine
  if (:y < 310) [
    messagebox [Screen Problem] [The screen height needs to be at least 310. Set the Asteroid Miner shortcut accordingly. (Try "C:\\Program Files\\FMSLogofmslogo.exe -H 500 -W 700 -F -L AM.lgo" as the shortcut target.)]
    bye
  ]
  if (or (:x/:y < 1.39) (:x/:y > 1.405)) [
    messagebox [Screen Problem] [The screen width needs to be 1.4 times the height. Set the Asteroid Miner shortcut accordingly. If the Logo screen fills the desktop, the height or width may be too large, in which case Logo is ignoring it.]
    bye
  ]
end

to checkLogoVersion
   localmake "version splitversion item 2 logoversion
   if (or (lessp item 1 :version 6) (and equalp item 1 :version 6 lessp item 2 :version 32)) [
      messagebox [Version Problem] [This version of Asteroid Minor only runs on FMSLogo 6.33.0 or higher.]
      bye
   ]
end

to splitversion :version
   output splitversion.inner :version "|| []
end

to splitversion.inner :version :workingversion :accumulatedversion

  if empty? :version [
     ; We reached the end of the version
     output reverse fput :workingversion :accumulatedversion
  ]
  if equal? first :version ". [
     ; We reached the version delimiter
     output splitversion.inner (butfirst :version) "|| (fput :workingversion :accumulatedversion)
  ]

  output splitversion.inner (butfirst :version) (word :workingversion first :version) :accumulatedversion

end


to clearBox
  setturtle 0
  setxy (:displayWidth/2 - :displayWidth)+1 (:displayHeight/2 - :displayHeight)+1
  setfc[ 0 0 0 ]
  bitblock :displayWidth+1 :displayHeight+1
end

to commandDone
  make "displayHighScores "false
  make "open.quit "false
  make "displayInstructions "false
  buttonOn 8 "false
  buttonOn 7 "false
  make "menuOn :menuState
  make "doneButtonOn "false
end

to commandHighScores
  keyboardoff
  make "menuState :menuOn
  make "doneButtonOn "true
  make "displayHighScores "true
  make "open.quit "true
  menuOn "false
  buttonOn 1 "false
  make "bhDone "true
end

to commandInstructions
  keyboardoff
  make "menuState :menuOn
  make "doneButtonOn "true
  make "displayInstructions "true
  make "open.quit "true
  menuOn "false
  buttonOn 1 "false
  make "bhDone "true
end

to commandPlay
  mouseoff
  make "playing "true
  menuOn "false
  make "open.quit "true
end

to displayHighScores
  loadScores
  setturtle 0
  drawText [ High Scores ] "getLength
  setxy -( :textLength / 2 ) ( :displayHeight/2 - :textBarHeight*2 )
  drawText [ High Scores ] "draw
  repeat 10 [
    setturtle 0
    setxy (-12 * :scale * 17 / 2) ((22 * :scale) * 6 - (22 * :scale) * repcount)
    make "name item repcount :hiNames 
    drawText :name "draw
    make "scoreS item repcount :AM_Hiscores
    if :scoreS = 0 [ make "scoreS " ]
    drawText :scoreS "getLength
    setxy ((12 * :scale * 17 / 2 ) - :textLength) ((22 * :scale) * 6 - (22 * :scale) * repcount)
    drawText :scoreS "draw
  ]
end

to displayInstructions
  clearBox
  setturtle 0
  drawText [ Instructions ] "getLength
  setxy (-:textLength / 2)  ( :displayHeight/2 - 30*:textScale )
  drawText [ Instructions ] "draw
  make "ty :displayHeight/2 - 40*:textScale
  make "tx -:displayWidth/2 + 102*:textScale
  make "th -:displayWidth/2 + 66*:textScale  ;heading
  make "ti -:displayWidth/2 + 150*:textScale  ;indent
  make "line 32*:textScale
  setxy :th :ty - :line*1    drawText [Playing the game:] "draw
  setxy :ti :ty - :line*2    drawText [Navigate your mining ship through the asteroid field and] "draw
  setxy :tx :ty - :line*3    drawText [pick up the gems. \ When you have collected all the gems you] "draw
  setxy :tx :ty - :line*4    drawText [can see, you advance to the next level to mine a new section of] "draw
  setxy :tx :ty - :line*5    drawText [the asteroid field. \ If you can finish all 13 levels, you win!] "draw
  setxy :ti :ty - :line*6    drawText [Don't get going too fast. \ In space, the only way to slow] "draw
  setxy :tx :ty - :line*7    drawText [down is to turn around and fire your engine in the other] "draw
  setxy :tx :ty - :line*8    drawText [direction. \ By the time you finish doing that, you may be dust!] "draw
  setxy :th :ty - :line*9.5  drawText [Ship controls:] "draw
  setxy :tx :ty - :line*10.5 drawText [J....Turn the ship to the left] "draw
  setxy :tx :ty - :line*11.5 drawText [K....Fire the engines] "draw
  setxy :tx :ty - :line*12.5 drawText [L....Turn the ship to the right] "draw
  setxy :th :ty - :line*14   drawText [Game controls:] "draw
  setxy :tx :ty - :line*15   drawText [Q....Quit] "draw
  setxy :tx :ty - :line*16   drawText [P....Pause or Reset] "draw
end

to displayText :text :pause
  ; Clears the screen and shows :text rendered in the center for :pause ticks.
  clearBox
  drawText :text "getLength
  setxy -:textLength/2  0 
  drawText :text "draw
  waitStop :pause
end

to drawChar :c :action
  make "validChar "true
  setturtle 0
  ;a pen size of 2 doesn't look nice, so we'll use it in as small a range as possible
  ifelse and(:scale >= 1.9) (:scale < 2.5) [ make "textPenSize 3 ][ make "textPenSize round :scale ]
  setpensize :textPenSize
  seth 0
  make "cPos pos
  make "x first :cPos
  make "y last :cPos
  make "x round :x
  make "y round :y
  setxy :x :y
  setpc [ 255 255 0 ]
  pendown
  if :action <> "getLength [
    if :c=ascii "A [tfd 11 make "pos1 pos penup tfd 10 rt 90 tfd 5.5 make "pos2 pos tfd 5.5 rt 90 tfd 10 pendown rt 90 tfd 11 tbk 11 lt 90 tfd 11 tbk 11 setpos :pos2 setpos :pos1]
    if :c=ascii "B [penup tfd 21 pendown rt 90 tfd 10 rtCnr tfd 7 rtCnr tfd 6 lt 180 tfd 6 rtCnr tfd 10 rtCnr tfd 10 tbk 4 rt 90 tfd 21]
    if :c=ascii "C [penup rt 90 tfd 11 rt 180 pendown tfd 10 rtCnr tfd 19 rtCnr tfd 10]
    if :c=ascii "D [rt 90 tfd 10 ltCnr tfd 19 ltCnr tfd 10 tbk 4 lt 90 tfd 21]
    if :c=ascii "E [rt 90 tfd 11 tbk 11 lt 90 tfd 12 rt 90 tfd 10 tbk 10 lt 90 tfd 9 rt 90 tfd 12]
    if :c=ascii "F [tfd 12 rt 90 tfd 10 tbk 10 lt 90 tfd 9 rt 90 tfd 12]
    if :c=ascii "G [penup rt 90 tfd 11 lt 90 pendown tfd 12 lt 90 tfd 5 tbk 5 rt 90 tbk 12 lt 90 tfd 10 rtCnr tfd 19 rtCnr tfd 10 fd 1]
    if :c=ascii "H [tfd 12 rt 90 tfd 11 tbk 11 lt 90 tfd 9 fd 1 penup rt 90 tfd 11 rt 90 fd 1 pendown tfd 21 fd 1]
    if :c=ascii "I [penup rt 90 pendown tfd 6 tbk 3 lt 90 tfd 21 lt 90 tfd 3 bk 1 tbk 6]
    if :c=ascii "J [penup tfd 7 rt 180 pendown tfd 6 ltCnr tfd 6 ltCnr tfd 20 lt 90 tfd 3 tbk 6 bk 1]
    if :c=ascii "K [penup rt 90 tfd 11 rt 90 fd 1 make "pos1 pos bk 1 lt 90 tbk 11 lt 90 pendown tfd 12 make "pos2 pos tfd 9 fd 1 rt 90 penup tfd 11 rt 90 tfd 1 pendown setpos :pos2 setpos :pos1]
    if :c=ascii "L [rt 90 tfd 11 tbk 11 lt 90 tfd 22]
    if :c=ascii "M [penup rt 90 tfd 11 lt 90 pendown tfd 21 make "pos1 pos tbk 21 lt 90 penup tfd 5.5 rt 90 tfd 12 make "pos2 pos tbk 12 lt 90 tfd 5.5 rt 90 pendown tfd 21 setpos :pos2 setpos :pos1]
    if :c=ascii "N [penup rt 90 tfd 11 pendown make "pos1 pos lt 90 tfd 21 tbk 21 penup lt 90 tfd 11 rt 90 pendown tfd 21 setpos :pos1]
    if :c=ascii "O [penup tfd 1 pendown repeat 2 [ tfd 19 rtCnr tfd 9 rtCnr]]
    if :c=ascii "P [tfd 21 rt 90 tfd 10 rtCnr tfd 7 rtCnr tfd 10]
    if :c=ascii "Q [penup make "pos1 pos rt 90 tfd 11 lt 90 lt 45 pendown tfd 8 penup setpos :pos1 rt 45 tfd 1 pendown repeat 2 [ tfd 19 rtCnr tfd 8 rtCnr]]
    if :c=ascii "R [penup rt 90 tfd 11 rt 45 fd 1 make "pos1 pos bk 1 lt 45 tbk 11 lt 90 pendown tfd 21 rt 90 tfd 10 rtCnr tfd 7 rtCnr tfd 10 setpos :pos1]
    if :c=ascii "S [rt 90 tfd 10 ltCnr tfd 10 ltCnr tfd 9 rtCnr tfd 7 rtCnr tfd 10 fd 1]
    if :c=ascii "T [penup rt 90 tfd 5.5 pendown lt 90 tfd 21 lt 90 tfd 5.5 tbk 11]
    if :c=ascii "U [penup tfd 1 pendown tfd 20 rt 180 tfd 20 ltCnr tfd 9 ltCnr tfd 20 fd 1]
    if :c=ascii "V [penup rt 90 tfd 11 lt 90 tfd 21 rt 180 pendown tfd 11 make "pos1 pos penup tfd 10 rt 90 tfd 5.5 make "pos2 pos tfd 5.5 rt 90 tfd 10 pendown tfd 11 tbk 11 setpos :pos2 setpos :pos1 fd 1]
    if :c=ascii "W [penup rt 90 tfd 11 lt 90 tfd 21 rt 180 rt 90 tfd 11 lt 90 pendown tfd 21 make "pos1 pos tbk 21 lt 90 penup tfd 5.5 rt 90 tfd 9 make "pos2 pos tbk 9 lt 90 tfd 5.5 rt 90 pendown tfd 21 setpos :pos2 setpos :pos1]
    if :c=ascii "X [penup rt 90 tfd 11 lt 90 tfd 21 rt 180 penup make "pos1 pos tfd 21 lt 45 fd 1 make "pos2 pos bk 1 rt 45 rt 90 tfd 11 lt 45 fd 1 make "pos3 pos bk 1 rt 45 rt 90 tfd 21 pendown setpos :pos2 penup setpos :pos1 pendown setpos :pos3]
    if :c=ascii "Y [penup rt 90 tfd 11 lt 90 tfd 21 rt 45 fd 1 make "pos1 pos bk 1 lt 45 tbk 21 lt 90  tfd 5.5 rt 90 tfd 12 make "pos2 pos tbk 12 lt 90 tfd 5.5 rt 90 tfd 21 pendown setpos :pos2 rt 180 tfd 12 tbk 12 setpos :pos1]
    if :c=ascii "Z [make "pos1 pos rt 90 tfd 12 penup tbk 1 lt 90 tfd 21 pendown lt 90 tfd 11 tbk 11 setpos :pos1]

    if :c=ascii "a [penup rt 90 tfd 1 pendown tfd 8 tbk 2 lt 90 tfd 12 lt 90 tfd 6 ltCnr tfd 10 ltCnr]  ;ugly
;    if :c=ascii "a [penup rt 90 tfd 1 pendown tfd 8 tbk 2 lt 90 tfd 7 make "pos1 pos lt 90 tfd 6 ltCnr tfd 5 ltCnr penup setpos :pos1 pendown lt 90 tfd 4 ltCnr tfd 5 ltCnr tfd 1]  ;too pretty
;    if :c=ascii "a [penup rt 90 tfd 7 lt 90 tfd 1 pendown tfd 11 lt 90 tfd 6 ltCnr tfd 10 ltCnr tfd 5 ltCnr lt 180 ltCnr tfd 1 fd 1]  ;also a bit too pretty
    if :c=ascii "b [penup rt 90 tfd 9 rt 180 tfd 1 pendown tfd 8 rt 90 tfd 21 tbk 9 rt 90 tfd 8 rtCnr tfd 10 rtCnr]
    if :c=ascii "c [penup rt 90 tfd 9 rt 180 pendown tfd 8 rtCnr tfd 10 rtCnr tfd 8 fd 1]
    if :c=ascii "d [penup rt 90 tfd 1 pendown tfd 8 lt 90 tfd 21 tbk 9 lt 90 tfd 8 ltCnr tfd 10 lt 45 tfd 1.4]
    if :c=ascii "e [penup rt 90 tfd 8 rt 180 pendown tfd 7 rtCnr tfd 10 rtCnr tfd 7 rtCnr tfd 5 rt 90 tfd 9]
    if :c=ascii "f [penup rt 90 tfd 4 pendown lt 90 tfd 12 lt 90 tfd 4 tbk 8 tfd 4 rt 90 tfd 8 rtCnr tfd 4]
    if :c=ascii "g [penup rt 90 tfd 9 rt 180 pendown tfd 8 rtCnr tfd 10 rtCnr tfd 8 rt 90 tfd 17 rtCnr tfd 7 rtCnr tfd 1]
    if :c=ascii "h [tfd 21 tbk 9 rt 90 tfd 8 rtCnr tfd 11 fd 1]
    if :c=ascii "i [tfd 12 fd 1 penup tfd 3 pendown tfd 2]
    if :c=ascii "j [penup rt 90 tfd 4 lt 90 tfd 17 rt 180 pendown tfd 2 penup tfd 3 pendown tfd 17 rtCnr tfd 4]
    if :c=ascii "k [tfd 7 make "pos1 pos tfd 14 tbk 21 rt 90 penup tfd 9 fd 1 rt 90 fd 1 make "pos2 pos bk 1 lt 90 bk 1 lt 90 tfd 12 pendown setpos :pos1 setpos :pos2]
    if :c=ascii "l [tfd 21 fd 1]
    if :c=ascii "m [tfd 12 rt 90 tfd 4 rtCnr tfd 11 rt 180 tfd 11 rtCnr tfd 3 rtCnr tfd 11 fd 1]
    if :c=ascii "n [tfd 12 rt 90 tfd 8 rtCnr tfd 11 fd 1]
    if :c=ascii "o [penup tfd 1 pendown repeat 2 [tfd 10 rtCnr tfd 7 rtCnr]]
    if :c=ascii "p [rt 90 tfd 8 ltCnr tfd 10 ltCnr tfd 8 lt 90 tfd 18 fd 1]
    if :c=ascii "q [penup rt 90 tfd 9 rt 180 pendown tfd 8 rtCnr tfd 10 rtCnr tfd 8 rt 90 tfd 18 fd 1]
    if :c=ascii "r [ tfd 11 rtCnr tfd 8]
;    if :c=ascii "r [tfd 12 tbk 2 rt 45 tfd 2.828 rt 45 tfd 6]  ;a bit too pretty. goes with nicer "a"
    if :c=ascii "s [rt 90 tfd 8 ltCnr tfd 4 ltCnr tfd 7 rtCnr tfd 4 rtCnr tfd 8 fd 1]
    if :c=ascii "t [penup rt 90 tfd 4 pendown lt 90 tfd 12 lt 90 tfd 4 tbk 8 tfd 4 rt 90 tfd 9 fd 1]
    if :c=ascii "u [penup tfd 12 rt 180 pendown tfd 11 ltCnr tfd 7 ltCnr tfd 11 fd 1]
    if :c=ascii "v [penup tfd 12 fd 1 make "pos1 pos bk 1 tbk 12 rt 90 tfd 4.5 make "pos2 pos tfd 4.5 lt 90 tfd 12 pendown setpos :pos2 setpos :pos1]
    if :c=ascii "w [penup tfd 6 pendown tfd 6 tbk 6 penup make "pos1 pos tbk 6 rt 90 tfd 2 make "pos2 pos tfd 2 lt 90 tfd 6 make "pos3 pos tbk 6 rt 90 tfd 2 make "pos4 pos tfd 2 lt 90 tfd 6 pendown tfd 6 tbk 6 setpos :pos4 setpos :pos3 setpos :pos2 setpos :pos1]
    if :c=ascii "x [penup rt 90 tfd 9 lt 90 tfd 12 rt 180 penup make "pos1 pos tfd 12 lt 45 fd 1.414 make "pos2 pos bk 1.414 rt 45 rt 90 tfd 9 lt 45 fd 1.414 make "pos3 pos bk 1.414 rt 45 rt 90 tfd 12 pendown setpos :pos2 penup setpos :pos1 pendown setpos :pos3]
    if :c=ascii "y [penup tfd 12 fd 1 make "pos1 pos bk 1 tbk 12 rt 90 tfd 2 rt 90 tfd 6 make "pos3 pos tbk 6 lt 90 tfd 2.5 make "pos2 pos tfd 4.5 lt 90 tfd 12 pendown setpos :pos2 setpos :pos3 setpos :pos2 setpos :pos1]
    if :c=ascii "z [make "pos1 pos rt 90 tfd 9 fd 1 penup bk 1 lt 90 tfd 12 pendown lt 90 tfd 9 tbk 9 setpos :pos1]

    if :c=ascii "0 [penup tfd 1 pendown repeat 2 [tfd 19 rtCnr tfd 9 rtCnr]]
    if :c=ascii "1 [penup rt 90 pendown tfd 10 tbk 5 lt 90 tfd 21 lt 90 tfd 5 fd 1]
    if :c=ascii "2 [penup rt 90 tfd 11 lt 90 pendown lt 90 tfd 11 rt 90 tfd 10 rtCnr tfd 9 ltCnr tfd 8 ltCnr tfd 10]
    if :c=ascii "3 [rt 90 tfd 10 ltCnr tfd 9 ltCnr tfd 10 rt 180 tfd 10 ltCnr tfd 8 ltCnr tfd 10 fd 1]
    if :c=ascii "4 [penup rt 90 tfd 11 lt 90 pendown tfd 21 tbk 10 lt 90 tfd 11 rt 90 tfd 10 fd 1]
    if :c=ascii "5 [rt 90 tfd 10 ltCnr tfd 9 ltCnr tfd 9 rtCnr tfd 9 rt 90 tfd 11]
    if :c=ascii "6 [penup tfd 1 pendown tfd 11 penup tbk 11 pendown rt 90 rt 45 tfd 1.414 lt 45 tfd 9 ltCnr tfd 9 ltCnr tfd 9 ltCnr lt 180 tfd 10 rtCnr tfd 10]
    if :c=ascii "7 [penup tfd 21 rt 90 pendown tfd 11 rt 90 tfd 21 fd 1]
    if :c=ascii "8 [penup tfd 1 pendown tfd 9 rt 45 tfd 1.414 tbk 1.414 lt 45 penup tbk 9 pendown rt 90 rt 45 tfd 1.414 lt 45 tfd 9 ltCnr tfd 9 ltCnr tfd 9 rtCnr tfd 8 rtCnr tfd 9 rtCnr tfd 8 rtCnr]
    if :c=ascii "9 [penup tfd 21 rt 90 tfd 11 rt 90 tfd 1 pendown tfd 11 penup tbk 11 pendown rt 90 rt 45 tfd 1.4 lt 45 tfd 9 ltCnr tfd 9 ltCnr tfd 9 ltCnr lt 180 tfd 10 rtCnr tfd 10]

    if :c=ascii ": [tfd 2 penup tfd 8 fd 1 pendown tfd 2]
    if :c=ascii "- [penup tfd 12 rt 90 pendown tfd 10]
    if :c=ascii "? [penup rt 90 tfd 5 lt 90 pendown tfd 2 penup tfd 3 pendown tfd 6 rtCnr tfd 4 ltCnr tfd 7 ltCnr tfd 8 ltCnr tfd 4]
    if :c=ascii "! [tfd 2 penup tfd 3 pendown tfd 17]
    if :c=ascii ". [tfd 2]
    if :c=ascii ", [penup tbk 4 rt 30 pendown tfd 3 lt 30 tfd 2 lt 90 tfd 3]
    if :c=ascii "' [penup tfd 17 rt 30 pendown tfd 3 lt 30 tfd 2 lt 90 tfd 3]
    if :c=ascii "\" [penup tfd 18 pendown tfd 4 fd 1 penup rt 90 tfd 4 rt 90 fd 1 pendown tfd 4 fd 1] ;actually a double quote
    if :c=ascii "_ [penup tbk 2 rt 90 pendown tfd 11]
 ]

  make "charWidth 0
  if( and :c > (ascii "A)-1  :c < (ascii "Z)+1 ) [make "charWidth 12]
  if( and :c > (ascii "a)-1  :c < (ascii "z)+1 ) [make "charWidth 10]
  if( and :c > (ascii "0)-1  :c < (ascii "9)+1 ) [make "charWidth 12]
  if :c=ascii "I  [make "charWidth 7]
  if :c=ascii "f  [make "charWidth 9]
  if :c=ascii "j  [make "charWidth 5]
  if :c=ascii "i  [make "charWidth 1]
  if :c=ascii "l  [make "charWidth 1]
  if :c=ascii "m  [make "charWidth 11]
  if :c=ascii "r  [make "charWidth 9]
  if :c=ascii "t  [make "charWidth 9]
  if :c=ascii "1  [make "charWidth 11]
  if :c=ascii ":  [make "charWidth 1]
  if :c=ascii "-  [make "charWidth 10]
  if :c=ascii "?  [make "charWidth 11]
  if :c=ascii "!  [make "charWidth 1]
  if :c=ascii ".  [make "charWidth 3] 
  if :c=ascii ",  [make "charWidth 5]
  if :c=ascii "'  [make "charWidth 5]
  if :c=ascii "\" [make "charWidth 6]
  if :c=ascii "_  [make "charWidth 11]
  if :c = 32      [make "charWidth 7]

  penup
  setpos :cPos
  seth 0

  ifelse :charWidth = 0 [ 
    make "validChar "false
  ][
    if :action <> "getLength [
      ;the 3 in "tfd 3" is assumed to be 3 by inputText.keyHit and most button procedures
      rt 90 tfd :charWidth tfd 3 lt 90
    ]
    make "textLength :textLength + :charWidth + 3
  ]

  make "x first pos
  make "y last pos
  make "x round :x
  make "y round :y
  setxy :x :y
end

to drawGem :pos1 :action
  ; Draws or erases a gem at a position.

  local "points
  if (last :pos1) <> :offScreenY [
    setturtle 0
    make "points array 6
    setpensize round :scale
    seth 0
    if :action = "draw [
      setpc item abs(remainder first(:pos1) 7) {
         [ 0   255 255 ]
         [ 255 160 190 ]
         [ 240 170 255 ]
         [ 0   180 255 ]
         [ 255 255 255 ] 
         [ 170 255 170 ]
         [ 255 255 170 ]
       }@0

      if :ee1 [
        setpc item abs(remainder first(:pos1) 2) {
          [ 255 100 100 ]
          [   0 255   0 ]
        }@0
      ]
    ]
    if :action = "erase [ setpc[ 0 0 0 ] ]

    repeat 6 [
      penup setpos :pos1 pendown
      ifelse( or repcount = 1 repcount = 4 ) [
        fd :gemRad
        setitem repcount :points pos
      ][
        fd :gemRad * 0.75
        setitem repcount :points pos
      ]

      ifelse( or repcount = 2 repcount = 5 ) [ rt 90 ] [ rt 45 ]
    ]
    setpos item 6 :points
    repeat 6 [ setpos item repcount :points ]
    penup
  ]
end

to drawRock :pos1
  local "points
  setturtle 0
  setpensize round 2*:scale
  make "x item 1 :pos1
  make "y item 2 :pos1
  make "d :x
  seth :d
  make "color (remainder (abs :y) 6)
  if :color = 0 [ setpc[ 120 120 120 ] ]
  if :color = 1 [ setpc[ 132 132 132 ] ]
  if :color = 2 [ setpc[ 144 144 144 ] ]
  if :color = 3 [ setpc[ 156 156 156 ] ]
  if :color = 4 [ setpc[ 150 133 111 ] ]
  if :color = 5 [ setpc[ 150 150 125 ] ]
  
  make "points array 18
  ;create a symetrical rock using twice as many points as that requires
  repeat 9 [
    setpos :pos1
    rt 360 / 9 fd :rockRad
    setitem repcount*2 - 1 :points pos
    setitem repcount*2 :points pos
  ]
  ;replace "random" points in the symetrical rock with nearby points to make it more
  ;irregular
  repeat 5 [
    ;select the point to mess with (must be between two points that are on the edge). Uses
    ;an expression based on the rock's screen position instead of a random number so that
    ;the same point is selected each time the rock is drawn
    if repcount = 1 [make "pt abs( (remainder :x 8) ) * 2 + 2 ]
    if repcount = 2 [make "pt abs( (remainder :y 8) ) * 2 + 2 ]
    if repcount = 3 [make "pt abs( (remainder (:x - :y) 8) ) * 2 + 2 ]
    if repcount = 4 [make "pt abs( (remainder (:x + :y) 8) ) * 2 + 2 ]
    if repcount = 5 [make "pt abs( (remainder (:x * 3) 8) ) * 2 + 2 ]

    ;move the point away from the edge
    setpos :pos1  seth :d
    if repcount = 1 [ rt 360 / 18 * (:pt + 1)  fd :rockRad - :rockRad / 3 ]
    if repcount = 2 [ rt 360 / 18 * (:pt + 1)  fd :rockRad - :rockRad / 3.5 ]
    if repcount = 3 [ rt 360 / 18 * (:pt + 1)  fd :rockRad - :rockRad / 4 ]
    if repcount = 4 [ rt 360 / 18 * (:pt + 1)  fd :rockRad - :rockRad / 4.5 ]
    if repcount = 5 [ rt 360 / 18 * (:pt + 1)  fd :rockRad ]
    make "pt :pt + 1
    setitem :pt :points pos
  ]

  setpos item 1 :points
  pendown
  ;connect the points to draw the rock
  repeat 18 [ setpos item repcount :points ]
  setpos item 1 :points
  penup

  setpensize round :scale
end

to drawShipExplosion :x :y :d

  repeat :numFrags [
    setxy :x :y  seth :d
    rt 360/:numFrags * repcount
    make "fal item repcount :fragments  ;fal stands for fragment attribute list
    fd :shipRad * (item 1 :fal) + :expStep * (item 2 :fal)
    rt (item 3 :fal) + :expStep * (item 4 :fal)
    pendown
    fd :expLen * (item 5 :fal) * :scale
    rt 180
    fd :expLen * (item 6 :fal) * :scale
    if (item 7 :fal) = 1 [ rt (item 8 :fal)  fd :expLen * (item 9 :fal) * :scale ]
    penup
  ]
end

to hideShip 
  repeat 4 [ setturtle repcount hideturtle ]
  setturtle 0
end

to moveShip :x :y :dr
  local "activeTurtle

  ; Determine which tutrle should be shown
  ifelse :isThrustOn [
    ifelse (20 * :glintSpeed) < :blink [
      ; thursting, with lights
      make "activeTurtle 4
    ][
      ; thursting, no lights
      make "activeTurtle 2
    ]
  ][
    ifelse (20 * :glintSpeed) < :blink [
      ; no thurst, with lights
      make "activeTurtle 3
    ][
      ; no thurst, no lights
      make "activeTurtle 1
    ]
  ]

  ; Position the turtle correctly
  setturtle :activeturtle
  setxy :x :y
  seth  :dr
  showturtle

  ; Hide the other sprites
  repeat 4 [ if :activeTurtle <> repcount [ setturtle repcount hideturtle ] ]

  ; Increment the blink counter
  ifelse :blink = (40 * :glintSpeed) [ 
     make "blink 0 
  ][
     make "blink :blink + 1
  ]

  setturtle 0
end

to drawShip :x :y :d :thickness :action
  ; :x      is xcor of ship
  ; :y      is ycor of ship
  ; :d      is heading of ship
  ; :action is "draw, "redraw, or "erase

  setturtle 0
  setpensize :thickness

  ifelse :shipGlow > :shipFadeStart [ 
     make "pencolor [255 255 255]
  ][
     make "pencolor (list
        (255 - 138) / :shipFadeStart * :shipGlow + 138  ; red
        (255 - 60)  / :shipFadeStart * :shipGlow + 60   ; green
        (255 - 255) / :shipFadeStart * :shipGlow + 255  ; blue
     )
  ]
  if :action = "erase [ 
     make "pencolor [ 0 0 0 ] 
  ]

  if :action = "draw [
    ; blink cyles through two seconds, then resets
    ifelse :blink = (40 * :glintSpeed) [ 
       make "blink 0 
    ][
       make "blink :blink + 1
    ]
  ]

  setpc :pencolor

  ifelse :shipIsExploding [

    ;explosion--random numbers for the fragment attribute lists are picked in playLoop
    if :action = "draw [ make "expLen :expLen - :shipRad / :numExpSteps ]
    repeat :numFrags [
      ; move the turtle to the begining of this piece of sharpnel
      setxy :x :y
      seth :d

      ; draw this piece of shrapnel
      rt 360/:numFrags * repcount
      make "fal item repcount :fragments  ;fal stands for fragment attribute list
      fd :shipRad * (item 1 :fal) + :expStep * (item 2 :fal)
      rt (item 3 :fal) + :expStep * (item 4 :fal)
      pendown
      fd :expLen * (item 5 :fal) * :scale
      rt 180
      fd :expLen * (item 6 :fal) * :scale
      if (item 7 :fal) = 1 [ rt (item 8 :fal)  fd :expLen * (item 9 :fal) * :scale ]
      penup
    ]
  ][
    ; draw right side of nose
    setxy :x :y
    seth :d + 67.5
    fd :shipRad3

    pendown
    fd :shipRad3 * 2 - :scale
    make "light1Pos pos
    fd :scale
    rt 112.5
    fd :shipSide

    ;draw back of ship, trace back over it partway, draw engine if thrusting, then trace forward again--
    ;this keeps the engine over top of all the other lines
    rt 45
    fd :shipSide - 1.414*:scale
    rt 45
    fd :shipSide + 2*:scale
    rt 45
    fd :shipSide - 1.414*:scale
    bk :shipSide - 1.414*:scale
    lt 45
    if ( or :isThrustOn  :action = "erase ) [
      setpensize :thickness*2
    ]
    if ( and (:leaveStep < :numLeaveSteps * .80) :isThrustOn (:action <> "erase) ) [
      setpc[ 255 230 130 ]
    ]
    bk :shipSide + 2*:scale

    setpc :pencolor
    setpensize :thickness

    penup
    fd :shipSide + 2*:scale
    rt 45
    fd :shipSide - 1.414*:scale
    pendown
    rt 45
    fd :shipSide

    ;draw left side of nose
    rt 112.5

    fd :scale
    make "light2Pos pos
    fd :shipRad3 * 2 - :scale


    ; draw the ship's nose
    lt 93.06
    fd 12.95 * :scale*:shipRad/:normalShipRad
    rt 141.11
    fd 12.95 * :scale*:shipRad/:normalShipRad
    penup

    ; draw the lights, now that we won't draw over them
    if (or :leaveStep < :numLeaveSteps * 0.5 not :isLeaving) [ 
       drawShip.light :light1Pos
       drawShip.light :light2Pos
    ]

    setxy :x :y
    seth :d+90
    pendown

    ;draw cockpit begin
    fd :shipRad6 / 2
    rt 45  fd :shipRad6Diag
    rt 45  fd :shipRad3
    rt 135 fd :shipRad6Diag lt 45 fd :shipRad6 lt 45 fd :shipRad6Diag 
    rt 135 fd :shipRad3
    rt 45  fd :shipRad6Diag
    rt 45  fd :shipRad6 / 2
    lt 90 penup
    ;draw cockpit end 
  ]
  if and( :shipGlow > 0 ) ( :action = "draw ) [ make "shipGlow :shipGlow - 1 ]
  make "erase "false

end

to drawShip.light :lightPos

  setpos :lightPos
  seth 225 fd 1.414*:scale

  ifelse :action = "erase [
    ; we are erasing the ship, so we erase the lights, too
    sbitblock round( 2*:scale ) round( 2*:scale )
  ][
    if (:blink > (20 * :glintSpeed - 1) ) [
      ; the light is on--draw it
      setfc [ 255 60 60 ] 
      sbitblock round( 2*:scale / (:leaveStep+1) ) round( 2*:scale / (:leaveStep+1) )
      setfc [ 0 0 0 ]
    ]
  ]

end

to drawText :txt :action
  ; If :action = "draw, then :txt is draw screen at the turtle's position
  ; using the configured :textScale.
  ; The global variable :textLength is updated to be the number of pixels
  ; of how wide the text is and the turtle is moved to the end of the text.
  ;
  ; If :action = "getLength, then only :textLength is updated and the turtle
  ; is not moved.
  setturtle 0
  make "tPos pos
  make "textLength 0
  seth 0
  ifelse listp :txt [
    make "numWords count :txt
    repeat :numWords [
      make "char item repcount :txt
      make "numChars count :char
      repeat :numChars [ drawChar ascii (item repcount :char) :action ]

      ; Add 6 text pixels of space between each word.
      if repcount <> :numWords [ rt 90 tfd 6 lt 90 make "textLength :textLength + 6 ]
    ]
  ][
    make "numChars count :txt
    repeat :numChars [ drawChar ascii (item repcount :txt ) :action ]
  ]

  make "textLength round( :textLength * :textScale  )
  if :action = "getLength[ penup setpos :tPos seth 0 ]
end 

to findXy :object
  make "findNew "false
  if :object = "rock [ 
    make "neighbor 0
    make "x round( (random round( :gameWidth - :rockRad*4 )) -
                   (:gameWidth - :rockRad*4) / 2 
                 ) 
    make "y round( (random round( :gameHeight - :rockRad*4 )) - 
                   (:gameHeight - :rockRad*4) / 2 - :textBarHeight / 2 
                 ) 
    setxy :x :y

    ;make sure rock is not on top of ship
    if (distance[ 0 0 ]) < ( :rockRad + :shipRad + 6 ) [ make "findNew "true ]

    ;make sure rock is not touching another--this must be the last thing checked for a rock
    ;if it is too close to another for a ship to pass between them, that's OK only if the other rock does not already have a neigbor
    repeat (:loop1 - 1) [
      if (distance( item repcount :rocks )) < ( :rockRad*2 + :shipRad*2 + 6 ) [
        ifelse( or(item repcount :rockNeighbors) > 0 (:neighbor>0) (distance( item repcount :rocks)) < :rockRad*2+3 ) [
          make "findNew "true
          make "neighbor 0
        ][
          make "neighboringRock repcount
          make "neighbor 1
        ]
      ]
    ]

    if and (not :findNew) (:neighbor > 0) [
      setitem :loop1 :rockNeighbors :neighbor
      setitem :neighboringRock :rockNeighbors :loop1
    ]
  ]

  if :object = "gem [ 
    make "x round( (random round( :gameWidth - :shipRad*3.2 )) -
                   (:gameWidth - :shipRad*3.2) / 2 
                 )
    make "y round( (random round( :gameHeight - :shipRad*3.2 )) -
                   (:gameHeight - :shipRad*3.2) / 2 - :textBarHeight / 2 
                 )
    setxy :x :y

    ;make sure gems don't overlap rocks
    repeat :numRocks [
      if (distance( item repcount :rocks )) < ( :rockRad + :gemRad + 2 ) [
         make "findNew "true
      ]
    ]

    ;make sure gem is not on top of ship
    if (distance[ 0 0 ]) < ( :gemRad + :shipRad + 2 ) [ make "findNew "true ]

    ;make sure gem is not too close to another
    if not :findNew [
      repeat (:loop1 - 1) [
        if (distance( item repcount :gems )) < ( :gemRad*2 + 2 ) [ make "findNew "true ]
      ]
    ]

    ;make sure gem is not so close to two rocks that the ship can't get to it
    if not :findNew [
      repeat :numRocks [
        if (distance( item repcount :rocks )) < ( :shipRad*2 + :rockRad + 2 ) [
          make "y :y+.001   ;marks gem as too close to a rock to glint (otherwise it would erase part of the rock)
          make "firstRock repcount
          repeat :numRocks [
            if repcount <> :firstRock [
              if (distance( item repcount :rocks )) < ( :shipRad*2 + :rockRad + 2 ) [ make "findNew "true ]
            ]
          ]
        ]
      ]
    ]
  ]  

  if (and :object = "rock  :findNew) [
    make "rockCounter :rockCounter + 1
    if :rockCounter < 250 [ findXy "rock ]
  ]
  if (and :object = "gem  :findNew) [ findXy "gem ]
end

to gameLoop
  make "quit "false

  while [not :quit] [ 

     make "reset "false

     capturekeyboardinput
     mouseon [ buttonHit ] [] [] [] []

     menuOn "false
     open.loop

     initGame
     levelLoop
  ]

end

to glint :action
  ; Performs one frame of glinting animation on a gem.
  ; The frame in the animation sequence is tracked by :glintStep
  ; There are 20*:glintSpeed frames in all.
  ; Only one gem may glint at a time.  This is tracked by :glintGem.

  if :glintStep = 1 [
    ; This is the first frame of animation.
    make "glintSize 0

    ; :speedup     - controls the glint's location.
    ; :rotateSpeed - controls the spin effect of the glint.
    make "speedUp random 3
    ifelse :speedUp = 0 [ make "rotateSpeed 0 ] [ make "rotateSpeed (random (20 / :glintSpeed)) + 5 ]
  ]

  ; If we are at the end of the animation, then simply redraw the gem.
  if :glintStep = (20 * :glintSpeed) [ drawGem (item :glintGem :gems) "draw ]

  setpensize round :scale

  ; Move to where on the gem the glint should appear.
  penup
  setpos item :glintGem :gems
  seth 0
  run item :speedUp {
     [ rt 45  fd :gemRad * 0.75 lt 45  ]
     [ lt 45  fd :gemRad * 0.75 rt 45  ]
     [ rt 135 fd :gemRad * 0.75 lt 135 ]
  }@0

  if :glintStep > 1 [
    ; erase the previous glint by drawing over it in black.
    pendown
    setpc [ 0 0 0 ]
    rt :rotateSpeed * (:glintStep-1)
    repeat 4 [ fd :glintSize bk :glintSize rt 90 ]

    ; redraw the gem, since we erased part of it.
    localmake "savedpos pos
    drawGem (item :glintGem :gems) "draw
    setpos :savedpos
    seth 0
  ]
  if and :glintStep < (20 * :glintSpeed) :action = "animate [

    ; Determine how large the glint should be.
    ; The glint gets larger until the halfway point (10*:glintSpeed)
    ; then gets smaller.
    if :glintStep < (10 * :glintSpeed + 1) [
      ; make the glint larger
      make "glintSize :scale*:glintStep/:glintSpeed
    ]
    if :glintStep > (10 * :glintSpeed) [
      ; make the glint smaller
      make "glintSize :scale*( (20*:glintSpeed + 1) - :glintStep)/:glintSpeed
    ]
 
    ; Draw the glint (which is just a simple white cross)
    setpc [ 255 255 255 ]
    if :speedUp = 0 [ make "rotateSpeed :rotateSpeed + 2 ]
    rt :rotateSpeed * :glintStep
    pendown
    repeat 4[ fd :glintSize bk :glintSize rt 90 ]
  ]
  penup

end

to hitGemCheck

  ; Checks all gems, whether they are on the screen or not.
  ; This keeps the speed more constant on slow computers.
  repeat :maxGems [
    make "gemPosition item repcount :gems
    make "dist2 (sum
        power (:shipX - first :gemPosition) 2 
        power (:shipY - last  :gemPosition) 2)
    ifelse :shipIsExploding [
      if :dist2 < (:shipGem2 * 4) [
        drawGem (item repcount :gems) "draw
      ]
    ][
      if :dist2 < :shipGem2 [
        ; The player grabbed a gem.

        ; Stop any glinting effect on the gem.
        if and :glintStep < (20 * :glintSpeed) :glintGem = repcount [
          make "glintStep :glintStep + 1
          glint "erase
          make "glintStep (20 * :glintSpeed)
        ]

        ; Erase the gem.
        drawGem :gemPosition "erase
        setitem repcount :gems (list :offScreenX :offScreenY)
        make "numGems :numGems - 1
        if :numGems = 0 [
          ; This was the last gem to get.  Level complete!
          make "bonus :timeLeft * 5
          make "isLeaving "true
          make "isThrustOn "true
          timerOff
          hideShip
        ]
        make "score :score + :gemWorth
        updateStatusBonus
        updateStatusScore
        make "gemWorth :gemWorth + 5
        make "shipGlow :shipFadeStart + 4
      ]
    ]
  ]
end

to hitRockCheck
  ; Checks all rocks, whether they are on the screen or not.
  ; This keeps the speed more constant on slow computers
  repeat :numRocks [
    ; Calculate the square of the euclidian distance between the ship and the rock.
    make "rockPosition item repcount :rocks
    make "dist2     (power (:shipX - first :rockPosition) 2) + (power (:shipY - last :rockPosition) 2)
    make "shipRock2 (power (:shipRad + :rockRad) 2)
    if :dist2 < (:shipRock2 * 2) [
      ; The ship is close to the rock.

      if :dist2 < :shipRock2 [
        ; The ship is touching a rock.

        if and not :isLeaving  not :shipIsExploding [
          ; The ship hit a rock.  Life Over!.
          timerOff
          hideShip

          ; Save the point where the ship hit the rock (for the explosion bitmap)
          make "explosionCenter (list (:shipX - :shipRad ) (:shipY - :shipRad ) )
          make "shipIsExploding "true
          make "expLen :shipRad
        ]
        if :isLeaving [
          ; Set a flag to skip drawing the warp-smear effect.
          make "isBehindRock "true
        ]
      ]

      if or :shipIsExploding :isLeaving [
        ; The ship is close enough that it may have overdrawn is recently.
        ; Redraw the rock, just in case part of it was erased by the
        ; exploding or leaving effect.
        drawRock :rockPosition
      ]
    ]
  ]
end

to initGame
  make "score 0
  make "level 1
  make "lives 4
  make "gameOver "false
  wrap

  ; recreate turtles 0-5
  repeat 5 [ setturtle repcount - 1 hideturtle penup ]
  repeat 4 [ setturtle repcount (bitmapturtle "true) ]

  setpensize round :scale
end

to initLevel
  make "quit "false
  make "reset "false
  make "timeLeft 40 + :level * 40
  make "numGems :level * 2 + 2
  make "numRocks :level * 2
  make "levelIsOver "false
  make "isBehindRock "false
  make "gemWorth 40
  setShipSize :normalShipRad

end

to initLife
  clearBox
  repeat :numRocks [ drawRock (item repcount :rocks) ]
  repeat :maxGems [ drawGem (item repcount :gems) "draw ]

  make "key 0
  make "shipX 0
  make "shipY 0
  make "dr 0
  make "oldShipX  :shipX
  make "oldShipY  :shipY
  make "oldShipDr :dr
  make "shipDeltaX 0
  make "shipDeltaY 0
  make "turnRt "false
  make "turnLt "false
  make "isThrustOn "false
  make "shipIsExploding "false
  make "isLeaving "false
  make "expStep 0
  make "leaveStep 0
  make "erase "false
  make "lifeOver "false
  make "shipGlow 0
  make "blink 0 ;controls the ships blinking lights
  make "glintCystal 1
  make "glintStep 100
  make "rockDrawCount 1
  make "gemDrawCount 1
end

to initMain
  make "scale (item 4 machine) / 500  ;sets the game scale based on the height set on the command line
  repeat 5 [ setturtle repcount - 1 hideturtle penup ]
  make "displayWidth item 3 machine
  make "displayHeight item 4 machine
  make "textLength 0
  make "numRocks 0
  make "numGems 0
  make "score 0
  make "displayHighScores "false
  make "displayInstructions "false
  make "doneButtonOn "false
  make "pauseNow "false
  make "paused "false
  make "playing "false
  make "glintGem 0
  make "timer "false
  sbitblock 1 1
  make "ee1 and (item 2 time) = "Dec (and (item 3 time) > 22 (item 3 time) < 27)
  make "ee2 and (item 2 time) = "Mar (item 3 time) = 11

;CONSTANTS
  ;These scales aren't all the same because I changed my mind on sizes a few times:
  make "open.scale 1.25 * :scale
  make "textScale (5/6) * :scale
  make "numFrags 7   ;number of framents in an explosion
  make "gemRad 8 * :scale   ;gems should be wider than maxSpeed
  make "textBarHeight 24 * :scale
  make "gameWidth :displayWidth
  make "gameHeight :displayHeight - :textBarHeight
  make "maxLevel 13
  make "rockRad 25 * :scale
  make "normalShipRad 14 * :scale
  setShipSize :normalShipRad

  ;it's faster if the math is done here, once, and saved in a variable
  make "shipGem2 (:shipRad + :gemRad)*(:shipRad + :gemRad) ;distance squared

  make "maxGems :maxLevel * 2 + 2
  make "maxRocks :maxLevel * 2
  make "rocks (array :maxRocks 1)
  make "rockNeighbors (array :maxRocks 1)
  make "gems (array :maxGems 1)
  make "offScreenX 0
  make "offScreenY :displayHeight / 2 + :rockRad * 4

  repeat :maxGems [ setitem repcount :gems ( list :offScreenX :offScreenY ) ]
  repeat :maxRocks [ setitem repcount :rocks ( list :offScreenX :offScreenY ) ]
  repeat :maxRocks [ setitem repcount :rockNeighbors 0 ]

  make "Apos (list -175*:open.scale 105*:open.scale )
  make "Mpos (list -115*:open.scale 5*:open.scale )

  ;The rest of the constants control speed and frames per second.
  ;This first set is for modern computers and corresponds to 40 fps.
  make "animationDelay 25   ;in milliseconds
  make "turnSpeed 5
  make "numExpSteps 60
  make "numLeaveSteps 70
  make "acceleration .1 * :scale
  make "maxSpeed2 ( 6 * :scale ) * ( 6 * :scale )   ;maximum speed squared
  make "shipFadeStart 40   ;steps until the glowing ship starts to fade again
  make "glintSpeed 2   ;larger is slower--also controls speed of blinking spaceship lights

  ;This set corresponds to 20 fps.
  ;You can uncomment these to speed things up a little if you have a very old computer.
  ;make "animationDelay 50
  ;make "turnSpeed 10
  ;make "numExpSteps 30
  ;make "numLeaveSteps 35
  ;make "acceleration .4 * :scale
  ;make "maxSpeed2 ( 12 * :scale ) * ( 12 * :scale )   ;maximum speed squared
  ;make "shipFadeStart 20   ;steps until the glowing ship starts to fade again
  ;make "glintSpeed 1

;BITMAPS

  ; bitmap  1 - The ship (normal)
  ; bitmap  2 - The ship (thrusting)
  ; bitmap  3 - The ship (lights on)
  ; bitmap  4 - The ship (lights on with thrust)
  ; bitmap  5 - The large turtle in the intro screen
  ; bitmap  6 - The ship's explosion
  ; bitmap  7 - The word "Score:" for the scoreboard
  ; bitmap  8 - The word "Bonus:" for the scoreboard
  ; bitmap  9 - A small picture of the ship to indicate an extra life
  ; bitmap 10 - The numeral 0 (used for scoreboard)
  ; bitmap 11 - The numeral 1 (used for scoreboard)
  ; bitmap 12 - The numeral 2 (used for scoreboard)
  ; bitmap 13 - The numeral 3 (used for scoreboard)
  ; bitmap 14 - The numeral 4 (used for scoreboard)
  ; bitmap 15 - The numeral 5 (used for scoreboard)
  ; bitmap 16 - The numeral 6 (used for scoreboard)
  ; bitmap 17 - The numeral 7 (used for scoreboard)
  ; bitmap 18 - The numeral 8 (used for scoreboard)
  ; bitmap 19 - The numeral 9 (used for scoreboard)
  ; bitmap 20 - The portion of the game screen obscured by the Paused screen.

  ; Set bitmap 1 to be a ship in the normal state.
  ; We draw the ship on a white background so that the non-line
  ; portions are transparent.
  initLife
  setscreencolor "white
  drawShip :shipRad :shipRad 0 2 "draw
  setbitindex 1
  setfloodcolor "white
  setpos [0 0]
  sbitcut round( :shipRad * 2 )+1 round( :shipRad  * 2 )+1

  ; Set bitmap 2 to be a ship in the thrusting state.
  make "isThrustOn "true
  drawShip :shipRad :shipRad 0 2 "draw
  setbitindex 2
  setpos [0 0]
  sbitcut round( :shipRad * 2 )+1 round( :shipRad  * 2 )+1

  ; Set bitmap 3 to be a ship with its lights on
  make "blink 20 * :glintSpeed
  make "isThrustOn "false
  drawShip :shipRad :shipRad 0 2 "draw
  setbitindex 3
  setpos [0 0]
  sbitcut round( :shipRad * 2 )+1 round( :shipRad  * 2 )+1

  ; Set bitmap 4 to be a thrusting ship with its lights on
  make "isThrustOn "true
  drawShip :shipRad :shipRad 0 2 "draw
  setbitindex 4
  setpos [0 0]
  sbitcut round( :shipRad * 2 )+1 round( :shipRad  * 2 )+1

  ; Load the bitmaps to the screen
  setxy 0 0
  bitload "AM_bitmaps.bmp

  ; Create a turtle that is a large turtle that falls
  ; into place during the intro sequence.
  setbitindex 5
  setxy  0  42
  bitcut 80 110
  bitfit round(53*:open.scale) round(73*:open.scale)

  ; load the ship's explosion
  setturtle   0
  setbitindex 6
  setpos [0 0]
  bitcut 42 42
  bitfit round(:shipRad*2.5*:scale) round(:shipRad*2.5*:scale)

  ; Load the word "Score:" into bitmap 7
  setbitindex 7
  setpos [0 0]
  setscreencolor "black
  drawText [Score:] "draw
  make "scoreLength :textLength
  setpos [0 0]
  sbitcut :textLength round( 18 * :scale )+1 

  ; Load the word "Bonus:" into bitmap 8
  setbitindex 8
  setpos [0 0]
  drawText [Bonus:] "draw
  make "bonusLength :textLength
  setpos [0 0]
  sbitcut :textLength round( 18 * :scale )+1 

  ; Load a small ship that signifies remaining lives to
  ; bitmap 9
  setbitindex 9
  setShipSize 9 * :scale
  initLife
  drawShip 0 0 0 1 "draw 
  penup seth 270 fd :shipRad lt 90 fd :shipRad
  sbitcut round( 18 * :scale )+1 round( 18 * :scale )+1 
  setShipSize :normalShipRad

  ; load each digit into a bitmap (indexes 10-19)
  repeat 10 [
    setbitindex repcount + 9
    setpos [0 0]
    drawChar (ascii "0) - 1 + repcount "draw 
    setpos [0 0]
    sbitcut round( 10 * :scale )+1 round( 18 * :scale )+1 
  ]

;BUTTONS
  make "numButtons 10
  make "buttonList array :numButtons
  setitem 1  :buttonList (list [Menu]         "true  (list 0 -:displayHeight/2+4 ))
  setitem 2  :buttonList (list [Menu Off]     "false (list 0 -:displayHeight/2+4 ))
  setitem 3  :buttonList (list [Play]         "false (list -90*:scale -:displayHeight/2+4 ))
  setitem 4  :buttonList (list [Instructions] "false (list -197*:scale -:displayHeight/2+4 ))
  setitem 5  :buttonList (list [Quit]         "false (list 90*:scale -:displayHeight/2+4 ))
  setitem 6  :buttonList (list [High Scores]  "false (list 192*:scale -:displayHeight/2+4 ))
  setitem 7  :buttonList (list [Done]         "false (list 0 -:displayHeight/2+4 ))
  setitem 8  :buttonList (list [Done]         "false (list 0 -:displayHeight/2+4 ))
  setitem 9  :buttonList (list [Continue]     "false (list 0 8*:textScale ))
  setitem 10 :buttonList (list [Reset]        "false (list 0 -42*:textScale ))

;HIGH SCORE FILE CHECK
  make "filelist files
  make "fileExist "false
  repeat count :filelist[
    if (item repcount :filelist) = "AM_Hiscores [ make "fileExist "true ]
  ]
  if not :fileExist [
    openwrite "AM_Hiscores
    setwrite "AM_Hiscores
    print "AsteroidMinerHS
    closeall
    setwrite []
  ]
end

to initObjects
  do.while [
    repeat :maxRocks [ setitem repcount :rocks (list :offScreenX :offScreenY ) ]  ;clear the rock list
    repeat :maxRocks [ setitem repcount :rockNeighbors 0 ]  ;clear the neighbor list
   
    make "rockCounter 0

    make "loop1 1  ;findXy needs this value--it's the number of rocks so far
    repeat :numRocks [
      if :rockCounter <> 250 [
        findXy "rock 
        setitem :loop1 :rocks ( list :x :y )
      ]
      make "loop1 :loop1 + 1
    ]
  ][ :rockCounter = 250 ]  ;if rockCounter = 250, then it tried too long to find spots for new rocks,
                           ;so it will start placing them all over again

  repeat :maxGems [ setitem repcount :gems (list :offScreenX :offScreenY ) ]  ;clear the gem list

  make "loop1 1  ;findXy needs this value--now it's the number of gems so far
  repeat :numGems [
    findXy "gem
    setitem :loop1 :gems ( list :x :y )
    make "loop1 :loop1 + 1
  ]
end

to inputText :iPos :txt :max
  setfocus [ MSWLogo Screen ]
  setpos :iPos
  drawText :txt "draw
  drawChar 32 "draw
  make "iPos pos
  penup
  drawText [_] "draw

  make "key 0
  make "string "
  keyboardon [ inputText.keyHit ]
  
  do.while [ wait 2 ][ :key <> 13 ]

  keyboardoff
  output :string
end

to inputText.eraseChar :char
  drawText :char "getLength
  penup seth 0 tbk 9 lt 90 fd :textLength
  setpc [ 0 0 0 ]
  pendown rt 90 tfd 33 penup tbk 33
  sbitblock round( :textLength + 1 ) round( 33 * :textScale )
  tfd 9
end

to inputText.keyHit
  make "key keyboardvalue

  ifelse :key = 8 [ ; backspace
    if (count :string) > 0 [

      if (count :string) <> :max [ inputText.eraseChar "_ ]
      ifelse (count :string) <> :max [
        inputText.eraseChar (item (count :string) :string)
      ][
        ;erase either the last character or the underscore--whichever is longer
        drawText [_] "getLength
        make "underscoreLength :textLength
        drawText (item (count :string) :string) "getLength
        ifelse :underscoreLength > :textLength [
          inputText.eraseChar "_
        ][
          inputText.eraseChar (item (count :string) :string)
        ]
      ]

      make "s :string
      make "string "
      repeat (count :s) - 1 [ make "string word :string (item repcount :s) ]

      drawText [_] "draw
    ]
  ][
    if (count :string) <> :max [ inputText.eraseChar "_ ]

    drawText ( char :key ) "getLength
    if :validChar [
      if (count :string) <> :max [
        make "string word :string (char :key)
        drawText ( char :key ) "draw
        if (count :string) = :max [
          penup lt 90 fd :textLength
          drawText [_] "draw
        ]
      ]
    ]
    if (count :string) <> :max [ drawText [_] "draw ]
  ]
end

to levelLoop
  while [ (and (not :quit) (not :reset) (not :gameOver)) ] [
    initLevel

    ; this block pauses while the objects' positions are selected, then 
    ; continues pausing until one second has gone by if it hasn't already
    make "start timemilli
    ifelse :level < :maxLevel [ displayText ( list "Level  :level ) 0 ] [ displayText [Last Level] 0 ]
    initObjects
    make "now timemilli
    while [ :now - :start < 1000 ] [ make "now timemilli ]

    lifeLoop

    if :levelIsOver [

      displayText (list "Level :level "Complete!) 60
      ifelse ( :timeLeft > 0 ) [ displayText [Adding Bonus...] 0 ] [ displayText [No Bonus] 0 ]

      ; Redraw the "Bonus" and "Score" elements of the status bar.
      statusDrawBonus
      updateStatusBonus
      statusDrawScore
      updateStatusScore

      waitStop 30
      if( :timeLeft > 0 ) [ addBonus 1 ]
      waitStop 60
      make "level :level + 1
    ]
    if :level > :maxLevel [
      ; The player has beaten the final level.  They win!
      make "gameOver "true
      displayText [Game Complete!] 120
      ifelse ( :lives > 1 ) [ displayText [Adding Extra Ship Bonus...] 0 ] [ displayText [No Extra Ship Bonus] 30 ]
      statusDrawBonus
      updateStatusBonus
      statusDrawScore
      updateStatusScore
      waitStop 30
      if( :lives > 1 ) [ addBonus 2 ]
      waitStop 30
    ]
  ]

  if (and not :quit  not :reset) [
    scoreCheck
  ]
end

to lifeLoop

  while [ (and  not :quit  not :reset  not :gameOver   not :levelIsOver) ] [
    if :lives > 1 [
      displayText [Get Ready!] 60
    ]
    if :lives = 1 [
      displayText [Last Ship...Get Ready!] 60
    ]

    initLife
    timerOn
    playLoop
    timerOff
    if( and not :quit  not :reset ) [ waitStop 60 ]
    if :lives = 0 [
      ; The player has died and has no extra lives.
      make "gameOver "true
      displayText [Game Over!] 0
      statusDrawScore
      updateStatusScore
      waitStop 50
    ]
  ]
end

to loadScores
  make "hiNames array 10
  make "AM_Hiscores array 10
  openread "AM_Hiscores
  setread "AM_Hiscores
  make "tempWord readword
  repeat 10 [
    make "tempWord1 readword
    make "tempWord2 "
    make "add repcount
    repeat (count :tempWord1) [ make "tempWord2 word :tempWord2 char ((ascii ( item repcount :tempWord1 ))-( 117 + :add )) ]
    setitem repcount :hiNames :tempWord2
    make "tempWord1 readword
    make "tempWord2 "
    repeat (count :tempWord1) [ make "tempWord2 word :tempWord2 char ((ascii ( item repcount :tempWord1 ))-( 117 + :add )) ]
    ifelse :tempWord2 = " [
      setitem repcount :AM_Hiscores 0
    ][
      setitem repcount :AM_Hiscores :tempWord2
    ]
  ]
  closeall
end

to ltCnr
  lt 45 tfd 1.4 lt 45
end

to menuOn :action
  if :action [ buttonOn 1 "false ]
  buttonOn 2 :action
  buttonOn 3 :action
  buttonOn 4 :action
  buttonOn 5 :action
  buttonOn 6 :action
  make "menuOn :action
  if and not :action  not :playing [ buttonOn 1 "true ]
end

to obk :d
  bk :d*:open.scale
end

to ofd :d
  fd :d*:open.scale
end

to ofdd :d
  fd :d*:open.scale
  if not :open.quit [wait 4]
end

to open
  ; Shows the opening sequence

  clearBox
  window ; so that the bouncing turtle starts above
  setturtle 5 hideturtle ; hide the bounce turtle
  bitmapturtle
  make "playing "false
  make "open.quit "false

  if :score > 0 [ statusDrawScore updateStatusScore  ]
  setpensize round 3*:open.scale
  setturtle 0
  open.stars

  menuOn :menuOn

  if not :open.quit [ waitStop 8 ]
  if :ee2 [open.author]
  open.ASTEROID
  open.MINER
  open.turtleO
  if not :open.quit [ waitStop 60 ]
  open.author
  repeat 7 [ if not :open.quit [ waitStop 30 ] ]

  clearBox
  setturtle 5 hideturtle ; hide the bounce turtle
  if (and not :displayHighScores not :displayInstructions not :open.quit) [ menuOn :menuOn ]

  if not :open.quit [ displayHighScores ]

  ifelse :displayHighScores [
    displayHighScores
    buttonOn 7 "true 
    capturekeyboardinput

    do.while [ waitStop 10 ] [ :displayHighScores ]
  ][
    repeat 8 [if not :open.quit [waitStop 30] ]
  ]

  if :displayHighScores [
    displayHighScores
    buttonOn 7 "true 
    capturekeyboardinput

    do.while [ waitStop 10 ] [ :displayHighScores ]
  ]

  if :displayInstructions [
    displayInstructions
    buttonOn 8 "true 
    capturekeyboardinput

    do.while [ waitStop 10 ] [ :displayInstructions ]
  ]
end

to open.ASTEROID
  setpc[ 200 120 255 ]
  ;A
  penup  setpos :Apos
  seth 180  obk 7  pendown
  seth 198
  ofd 55  make "oPos pos  ofdd 105  obk 160
  lt 30  ofdd 80
  obk 20
  seth 270  setpos :oPos  if not :open.quit [wait 4]
  ;S
  setpc[ 183 125 255 ]
  penup  setpos :Apos  seth 90  ofd 70  pendown
  seth 280  ofdd 30  
  lt 80  ofdd 30
  lt 115  ofdd 40
  rt 90  ofdd 40
  rt 80  ofdd 48
  ;T
  setpc[ 166 130 255 ]
  penup  setpos :Apos  seth 90  ofd 90  pendown
  ofdd 40  obk 20
  rt 95  ofdd 70
  ;E
  setpc[ 149 135 255 ]
  penup  setpos :Apos  seth 90  ofd 140  pendown
  seth 100  ofdd 40  obk 40
  rt 85  ofdd 60  obk 30
  lt 90  ofdd 25  obk 25  rt 90
  ofd 30
  lt 95  ofdd 35
  ;R
  setpc[ 132 140 255 ]
  penup  setpos :Apos  seth 90  ofd 190  pendown
  seth 180
  ofdd 60  obk 60
  lt 60  ofdd 30
  rt 120  ofdd 30
  lt 100  ofdd 50
  ;O skipped until later but pause like it is being done
  waitStop 8
  ;I
  setpc[ 115 145 255 ]
  penup  setpos :Apos  seth 90  ofd 290  pendown
  seth 85
  ofdd 14  obk 7
  rt 90  ofdd 70
  lt 80  obk 7  ofdd 14
  ;D
  setpc[ 100 150 255 ]
  penup  setpos :Apos  seth 90  ofd 320  pendown
  seth 175
  ofdd 75  make "oPos pos  obk 75
  lt 70  ofdd 40
  rt 60  ofdd 30
  setpos :oPos  if not :open.quit [waitStop 4]
end

to open.author
  local "fontAttribList
  setturtle 0
  penup
  setpos :Apos
  seth 180
  ofd 207
  rt 90
  ofd 50
  rt 180
  setpc( list 200*.9 120*.9 255*.9 )
  make "fontAttribList ( list [Times New Roman] round( 13 * :open.scale ) 0 0 400 0 0 0 0 0 0 0 0 )
  setlabelfont :fontAttribList
  ifelse :ee2 [
    label [by Dan Gerhards whose birthday is today!]
  ][
    label [by Dan Gerhards]
  ]
end

to open.loop
  open
  if not :open.quit [ open.loop ]
end

to open.MINER
  ;M
  setpc[ 200 125 255 ]
  penup  setpos :Mpos  pendown
  seth 195  ofdd 70  obk 70
  lt 65  ofdd 30
  lt 80  ofdd 30
  rt 120  ofdd 70
  ;I
  setpc[ 166 130 255 ]
  penup  setpos :Mpos  seth 90  ofd 75  pendown
  seth 95
  ofdd 14  obk 7
  rt 86  ofdd 65
  lt 85  obk 7  ofdd 14
  ;N
  setpc[ 149 135 255 ]
  penup  setpos :Mpos  seth 90  ofd 110  pendown
  seth 185  ofdd 60  obk 60
  lt 32  ofdd 72
  lt 151  ofdd 60
  ;E
  setpc[ 132 140 255 ]
  penup  setpos :Mpos  seth 0  obk 5  seth 90  ofd 165  pendown
  seth 87  ofdd 40  obk 40
  rt 95  ofdd 55  obk 30
  lt 90  ofdd 25  obk 25  rt 90
  ofd 30
  lt 85  ofdd 35
  ;R
  setpc[ 115 145 255 ]
  penup  setpos :Mpos  seth 90  ofd 220  pendown
  seth 180
  ofdd 70  obk 40  make "oPos pos  obk 30
  lt 80  ofdd 30 
  rt 45  ofdd 15
  setpos :oPos  if not :open.quit [wait 4]
  lt 8  ofdd 115
end

to open.stars
  penup
  repeat 400 [
    make "x random( round :displayWidth )
    make "y random( round :displayHeight )
    setxy (:x - :displayWidth / 2) (:y - :displayHeight / 2)
    setpixel[ 255 255 255 ]
  ]
end

to open.turtleO
  ; Animates the dropping of the large turtle that becomes
  ; the "O" in "Aster[O]id Miner" in the intro screen.
  setturtle 5
  penup  setxy (( first :Apos ) + 232*:open.scale) (:displayHeight / 2)
  showturtle
  make "speed 3
  make "oy last pos
  make "ox first pos
  make "bounce 0
  if not :open.quit [ open.turtleO.animate ]
  setxy :ox 40*:open.scale
end

to open.turtleO.animate
  waitStop 2
  make "speed :speed + 3*:open.scale
  make "oy :oy - :speed 
  if :oy < 40*:open.scale [
    make "oy :oy + ( 10*:open.scale - (:oy - 40*:open.scale) )
    make "speed (:speed - 10*:open.scale) * (-1)
    make "bounce :bounce + 1
    setxy :ox 40*:open.scale
    wait 1
  ]
  setxy :ox :oy*:open.scale
  if( and :bounce < round(3*1.25) not :open.quit ) [ open.turtleO.animate ]
end

to pauseGame
  local "keepOff
  make "keepOff "false
  make "pauseNow "false
  setturtle 0
  setxy -57*:scale -43*:scale
  setbitindex 20
  sbitcut round(110*:scale) round(90*:scale)
  hideShip

  buttonOn 9 "true
  buttonOn 10 "true

  if not :timer [ make "keepOff "true ]
  timerOff
  mouseon [ buttonHit ] [] [] [] []
  make "paused "true
  do.while [ eventcheck ][ :paused ]
  mouseoff
  if not :keepOff [ timerOn ]

  buttonOn 9 "false
  buttonOn 10 "false

  setturtle 0
  setxy -57*:scale -43*:scale
  setbitindex 20
  bitpaste
  wait 10
end

to playLoop

  ; Before entering the loop, setup the status bar at the top of the screen.
  statusDrawBonus
  updateStatusBonus
  statusDrawScore
  updateStatusScore

  updateStatusLives

  while [ (and (not :quit) (not :reset) (:expStep < :numExpSteps) (not :levelIsOver)) ] [
    noyield ; prevent keyboard/timer events from interrupting
    make "start timemilli

    ifelse :shipIsExploding [
      ; erase the previous animation frame.
      setpencolor "black
      drawShipExplosion :oldShipX :oldShipY :oldShipDr

      ; Advance to the next animation frame for the explosion.
      make "expStep :expStep + 1

      ; draw the current animation frame.
      setpencolor [138 60 255]
      make "expLen :expLen - :shipRad / :numExpSteps
      drawShipExplosion :shipX :shipY :dr

      ; When we're at the end of the animation, remove the life.
      if :expStep = :numExpSteps [ make "lives :lives - 1 ]
    ][
      ifelse :isLeaving [
        ; gradually shrink the ship for the "leaving level" effect.
        make "leaveStep :leaveStep + 1
        shrinkShip
        if :leaveStep = :numLeaveSteps [ make "levelIsOver "true ]

        drawShip :shipX :shipY :dr 2 "draw
      ][
        if (and not :levelIsOver   not :isBehindRock) [ 
          moveShip :shipX :shipY :dr
        ]
      ]
    ]

    hitGemCheck

    make "oldIsBehindRock :isBehindRock
    make "isBehindRock "false
    hitRockCheck

    ;if the ship just emerged from behind a rock, draw it now...
    ifelse :oldIsBehindRock [
        if (and not :levelIsOver   not :isBehindRock  not :isLeaving) [
            moveShip :shipX :shipY :dr
        ]
    ][
        ;...and if it just went behind one, erase it now
        if :isBehindRock [
            hideShip
        ]
    ]

    ; As time passes, the bonus always changes.
    updateStatusBonus

    if :shipIsExploding [
      ifelse :expStep = 0 [
        ; Show the explosion bitmap
        setpos :explosionCenter
        setbitindex 6
        bitpaste

        make "fragments array :numFrags
        repeat :numFrags [
          ; determine how this fragment should travel.
          setitem repcount :fragments ( list 
            ( (random 3) / 2 )
            ( (random 3 + 2) / 2 )
            ( random 360 )
            ( (random 61) + 10 )
            ( (random 4) * .25 + .5 )
            ( (random 6) * .25 )
            ( random 2 )
            ( (random 341) + 10 )
            ( (random 20) / 10 )
          )
        ]
      ][
        if :expStep = 2 [
          ; erase the explosion bitmap.
          setpos :explosionCenter
          sbitblock (round :shipRad * 2.5 * :scale) (round :shipRad * 2.5 * :scale)
        ]
      ]
    ]

    ifelse :glintStep < (20 * :glintSpeed) [
      ; We are in the middle of drawing a glint effect on a gem.
      ; Continue to the next frame of animation.
      make "glintStep :glintStep + 1
      glint "animate
    ][
      ; We are not glinting a gem.
      ; There's a 1-in-150 chance of starting a glint.
      if (random 150) = 0 [ 
        ;level*2+2 is the number of gems the level started with
        make "glintGem (random (:level*2+2) ) + 1
        make "y (last (item :glintGem :gems))

        ; if round :y != :y, then gem is close to a rock
        if and ((round :y) = :y) (:y <> :offScreenY) [ make "glintStep 0 ]
      ]
    ]

    if :shipIsExploding [
      make "oldShipX  :shipX
      make "oldShipY  :shipY
      make "oldShipDr :dr
    ]

    if :isLeaving [ make :isThrustOn "true ]
    processCommand
    

    make "shipX :shipX + :shipDeltaX
    make "shipY :shipY + :shipDeltaY

    ; if the center of the object is out of the box, wrap it around to the other side
    ifelse :shipX > (:gameWidth / 2 ) [
      make "shipX (:shipX - :gameWidth)
    ][
      if :shipX < -(:gameWidth / 2) [
        make "shipX (:shipX + :gameWidth)
      ]
    ]
    ifelse :shipY < -(:displayHeight / 2) [
      make "shipY (:shipY + :displayHeight )
    ][
      if :shipY > (:displayHeight / 2 ) [
        make "shipY (:shipY - :displayHeight )
      ]
    ]

    yield ; re-enabled timer/keyboard events
    while [ timemilli - :start < :animationDelay ] [wait 1]
  ]

end

to statusDrawBonus
  ; Paste the word "Bonus:" in the status bar.
  setturtle 0
  (setxy (:displayWidth / 2 - :displayWidth + 4 * :scale) 
         (:displayHeight / 2 - :textBarHeight + ((:textBarHeight-18 * :scale) / 2) ))
  setbitindex 8
  bitpaste
end

to updateStatusBonus

  ; Save a copy of :timeLeft in case it changes.
  local "timeLeftCopy
  make "timeLeftCopy :timeLeft

  ; Move to just after the "Bonus:"
  setturtle 0
  (setxy (:displayWidth / 2 - :displayWidth + :bonusLength + 7 * :scale)
         (:displayHeight / 2 - :textBarHeight + ((:textBarHeight-18 * :scale) / 2) ))
  seth 90

  repeat count (:timeLeftCopy * 5) [
    setbitindex (item repcount (:timeLeftCopy * 5) ) + 10
    bitpaste
    fd round( 13 * :scale )
  ]

  sbitblock round( 10 * :scale )+1 round( 18 * :scale )+1
end

to statusDrawScore
  ; Paste the word "Score:" in the status bar.
  setturtle 0
  (setxy
      -:scoreLength
      (:displayHeight / 2 - :textBarHeight + ((:textBarHeight-18 * :scale) / 2) ))
  setbitindex 7
  bitpaste
end

to updateStatusScore

  ; Paste the score just after the "Score:" text.
  setturtle 0
  (setxy
      (7 * :textScale)
      (:displayHeight / 2 - :textBarHeight + ((:textBarHeight-18 * :scale) / 2) ))
  seth 90
  repeat count :score [
    sbitblock round(13 * :scale + :scale)+1 round(18 * :scale + :scale)+1
    setbitindex (item repcount :score ) + 10
    bitpaste
    fd round( 13 * :scale )
  ]

end

to updateStatusLives
  ;print extra lives left
  setturtle 0
  make "extraLives :lives - 1
  if :extraLives < 0 [ make "extraLives 0 ]
  setxy (:displayWidth / 2 - 4) (:displayHeight / 2 - :textBarHeight + ((:textBarHeight-17 *:scale) / 2))
  seth 270
  setbitindex 9
  repeat :extraLives [ fd 20*:scale  bitpaste ]
  repeat 3 - :extraLives [ fd 20*:scale  sbitblock round( 18 * :scale ) round( 18 * :scale ) ]
end

to processCommand
  if not :shipIsExploding [
    if :turnLt   [ make "dr :dr - :turnSpeed ]
    if :turnRt   [ make "dr :dr + :turnSpeed ]
    if :dr > 360 [ make "dr :dr - 360 ]
    if :dr < 0   [ make "dr :dr + 360 ]

    if :isThrustOn [
      ;sin and cos are backwards because Logo calls 0 degrees straight up 

      make "shipDeltaX :shipDeltaX + ( sin :dr ) * :acceleration
      make "shipDeltaY :shipDeltaY + ( cos :dr ) * :acceleration
 
      if not :isLeaving [
        ;If the ship is at maximum speed, get rid of the extra speed, but leave the 
        ;direction alone. 
        make "speed2 (power :shipDeltaX 2) + (power :shipDeltaY 2) 
        if :maxSpeed2 < :speed2 [
          make "shipDeltaX (:maxSpeed2 * :shipDeltaX / :speed2)
          make "shipDeltaY (:maxSpeed2 * :shipDeltaY / :speed2)
        ]
      ]
    ]
  ]
  if :pauseNow [ pauseGame ]
end

to processKey :key :iskeydown [:keychar char :key]

  ;the first key of each pair is querty, the second is Dvorak
  ifelse :playing [
    if memberp :keychar "LN [ make "turnRt :iskeydown ]
    if memberp :keychar "JH [ make "turnLt :iskeydown ]

    if memberp :keychar "KT [
       ifelse :iskeydown [
          make "isThrustOn "true
       ][
          if not :isLeaving [ make "isThrustOn "false  make "erase "true ]
       ]
    ]

    if (and :keychar = "P    not :iskeydown    not :paused) [ 
       make "pauseNow "true
    ]

    if :iskeydown [
       if memberp :keychar "XQ [
          make "quit      "true
          make "open.quit "true
       ]

      if :paused [
         if :keychar = "C [ make "paused "false ]
         if :keychar = "R [ make "paused "false  make "reset "true ]
      ]
    ]
  ][
    if not :iskeydown [
      ifelse :doneButtonOn [
        if :keychar = "D [ commandDone ]
      ][
        if :keychar = "P [ commandPlay ]
        if :keychar = "I [ commandInstructions ]
        if :keychar = "H [ commandHighScores ]
        if :keychar = "M [ menuOn not :menuOn ] ; (toggle menu)
        if memberp :keychar "XQ [
           make "quit      "true 
           make "open.quit "true
        ]
      ]
    ]
  ]
end

to rtCnr
  rt 45 tfd 1.4 rt 45
end

to rungame
  catch "error [ fullscreen ]
  icon "Commander
  icon "Editor

  cs
  setfocus[MSWLogo Screen]
  checkLogoVersion
  checkScreen
  initMain

  gameLoop

  keyboardoff
  mouseoff
  bye
end

to saveScores
  openwrite "AM_Hiscores
  setwrite "AM_Hiscores
  print "AsteroidMinerHS
  repeat 10 [
    make "tempWord1 item repcount :hiNames
    make "tempWord2 "
    make "add repcount
    repeat (count :tempWord1) [ make "tempWord2 word :tempWord2 char ((ascii ( item repcount :tempWord1 ))+ 117 + :add ) ]
    print :tempWord2
    make "tempWord1 item repcount :AM_Hiscores
    make "tempWord2 "
    repeat (count :tempWord1) [ make "tempWord2 word :tempWord2 char ((ascii ( item repcount :tempWord1 ))+ 117 + :add ) ]
    ifelse :tempWord2 = "0 [
      print "
    ][
      print :tempWord2
    ]
  ]
  print "AsteroidMinerHS
  closeall
  setwrite[]
end

to sbit.position
  make "sPos pos
  make "sTurtle turtle
  make "sHeading heading
  setturtle 0
  penup
  setpos :sPos
  seth 0
  bk round( :scale ) - 1
  rt 90 bk round( :scale ) - 1
end

to sbitblock :swidth :sheight
  sbit.position
  bitblock :swidth + (round( :scale )-1)*2 :sheight + (round( :scale )-1)*2
  setturtle :sTurtle
  setpos :sPos
  seth :sHeading
end

to sbitcut :swidth :sheight
  sbit.position
  bitcut :swidth + (round( :scale )-1)*2 :sheight + (round( :scale )-1)*2
  setturtle :sTurtle
  setpos :sPos
  seth :sHeading
end

to scoreCheck
  loadScores
  ifelse :score > item 10 :AM_Hiscores [
    displayText [New High Score!] 0
    ;put the score on top of the screen
    statusDrawScore
    updateStatusScore 

    drawText [Enter your name: Dan_] "getLength  ;get the length with a typical(?) input
    make "name inputText (list ( 0 - :textLength/2 ) ( 0 - 18*:scale*3 ) ) [Enter your name: ] 11
    make "index 11
    make "done "false
    do.while [
      make "index :index - 1
      ifelse :score > item :index - 1 :AM_Hiscores [
        setitem (:index) (:AM_Hiscores) (item :index - 1 :AM_Hiscores)
        setitem (:index) (:hiNames) (item :index - 1 :hiNames)
      ][ setitem (:index) (:AM_Hiscores) (:score)
         setitem (:index) (:hiNames) (:name)
         make "done "true
      ]
    ][ and (not :done) (:index > 2) ]
    if not :done [ 
      setitem 1 (:AM_Hiscores) (:score)
      setitem 1 (:hiNames) (:name)
      make "done "true
    ]

    saveScores

    clearBox
    setturtle 5 hideturtle
    make "open.quit "false
    displayHighScores
    repeat 3 [if not :open.quit [waitStop 30] ]
  ][
    setwrite[]
    displayText [Final Score] 0
    ;put the score on top of the screen
    statusDrawScore
    updateStatusScore 
    waitStop 180
  ]
end

to setShipSize :rad
  make "shipRad :rad
  make "shipSide ( (sin 22.5) * :shipRad * 2 )
  make "shipRad3 :shipRad / 3
  make "shipRad6 :shipRad / 6
  make "shipRad6Diag :shipRad / 6 * 1.414
end

to shrinkShip
  make "shipRad :shipRad - :normalShipRad/:numLeaveSteps
  if :shipRad < 0 [ make "shipRad 0 ]
  setShipSize :shipRad
end

to tbk :dist
  bk :dist*:textScale
end

to tfd :dist
  fd :dist*:textScale
end

to timerOff
  if :timer [ cleartimer 1 ]
  make "timer "false
end

to timerOn
  ;make Windows call this code (timeLeft stuff) every 200 milliseconds
  settimer 1 200 [ if :timeLeft > 0 [ make "timeLeft :timeLeft - 1 ] ]
  make "timer "true
end

to waitStop :delay
  ; An interuptable alternative to "WAIT"
  repeat :delay [
    wait 1
    if or :reset :quit [ stop ]
    if :pauseNow [ pauseGame ]
  ]
end

make "startup [ rungame ]
